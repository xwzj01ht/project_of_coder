# Java类加载机制

## 类加载过程

### 加载

- 加载过程

	- 1.通过一个类的全限定名来获取定义此类的二进制字节流
	- 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
	- 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

- 二进制字节流来源

	- 从本地获取

		- 通常的类加载过程

			- 根据对应类的Jar文件中，直接加载类的二进制字节流

		- SPI类加载过程

			- 根据实际使用需要，加载特定的实现策略类；如JDBC针对不同数据库的驱动

	- 从网络获取

		- Applet应用

	- 运行时计算生成

		- 动态代理技术

			- 通过反射技术，在运行时生成特定接口的代理类的二进制字节流

	- 从其他文件生成

		- JSP技术

			- 由JSP文件生成对应的Class类

### 验证

- 验证的目的

	- 为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

- 验证的对象

	- 文件格式验证
	- 元数据验证
	- 字节码验证
	- 符号引用验证

### 准备

- 这一阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配

### 解析

- 这一阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

### 初始化

- 类初始化是类加载的最后一步，初始化阶段才真正开始执行类中定义的Java程序代码，这一阶段主要执行类构造器<clinit>()方法的过程

## 类加载机制

### 类的唯一性

- 类的唯一性是由类的全限定名和加载它的类加载器一同确定的，也就是被不同类加载器加载的两个相同的类，也必定不相等

### 双亲委派模型

- 虚拟机提供了一个非强制性的类加载机制，即双亲委派模型，他的过程是如果一个类加载器收到了类加载的请求，它首先不会自己取尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该首先传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己取加载；
其实对于虚拟机来说，只有两种加载器，一种是启动类加载器，是有C++语言实现的，是虚拟机的一部分；另外一部分是所有的其他类加载器，由Java语言编写，独立于虚拟机之外，都继承自抽象类java.lang.ClassLoader；
双亲委派模型还要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。这就形成了一种加载器的父/子关系。

### 线程上下文类加载器

- 双亲委派模型可以解决大部分类加载的问题，但不能解决所有场景。虚拟机允许灵活的设置类加载器，从而使类加载体系更加灵活：Thread.currentThread().setContextClassLoader(ClassLoader cl)
线程上下文类加载器完美的补充了双亲委派模型不能加载SPI机制实现类的问题。上下文类加载器默认就是AppClassLoader，当然我们可以自己实现上下文类加载器（TCCL）

## 案例

### Tomcat类加载机制

- 说明

	- Tomcat作为Web服务器，通常允许部署多个应用，那么多个应用之间怎么去做同一个类的隔离呢，这就需要由不同应用中不同类加载器来加载，才能实现隔离，而且多个应用也存在共用部分，下面我们结合Tomcat源码分析一下Tomcat的类加载器；
Bootstrap.java中初始化Tomcat类加载器，分别是commonLoader、catalinaLoader、sharedLoader。通过设置上下文类加载器可以灵活的使用不同类加载器加载应用中的类，完成多应用部署和热部署；
Tomcat不是彻底打破了双亲委派模型，而是灵活的使用上下文类加载器来解决热部署、多个应用部署等场景，顶层类加载还是遵循双亲委派模型的

- 类加载器

	- CommonLoader

		- Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问

	- CatalinaLoader

		- Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见

	- SharedLoader

		- 各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见

	- WebappClassLoader

		- 各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见

	- JasperLoader

		- 加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃。当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能

## 类加载器

### 启动/根类加载器

- 负责加载<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且被虚拟机识别的类库。如：rt.jar

### 扩展类加载器

- 负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路劲中的所有类库

### 应用程序/系统类加载器

- 负责加载用户类路径（ClassPath）上的所指定的类库

### 自定义类加载器

- 根据程序的需要，编写特定的类加载逻辑

## 什么是类加载机制

### Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行验证、准备、解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是Java虚拟机的类加载机制。

*XMind: ZEN - Trial Version*